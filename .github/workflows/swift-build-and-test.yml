#
# This source file is part of the Stanford Spezi open-source project
#
# SPDX-FileCopyrightText: 2025 Stanford University and the project authors (see CONTRIBUTORS.md)
#
# SPDX-License-Identifier: MIT
#

name: Build and test Swift Package on Linux

on:
  workflow_call:
    inputs:
      path:
        description: |
          The path where the project is located. Defaults to $GITHUB_WORKSPACE.
        required: false
        type: string
        default: '.'
      runsonlabels:
        description: |
          JSON-based collection of labels indicating which type of github runner should be chosen.
        required: false
        type: string
        default: '["ubuntu-latest"]'
      swiftVersion:
        description: |
          Specify the Swift language version when using xcodebuild.
        required: false
        type: string
        default: ''
      environment:
        description: |
          GitHub deployment environment to optionally adjust access to variables and secrets with additional protection rules.
          https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment
        required: false
        type: string
        default: ''
      checkout_submodules:
        description: |
          Flag indicating if submodules should be automatically checked out.
        required: false
        type: boolean
      checkout_lfs:
        description: |
          Flag indicating if git lfs should be used when running the check out step.
        required: false
        type: boolean
        default: false
      artifactname:
        description: |
          The name of the artifact that should be uploaded at the end of the build.
        required: false
        type: string
    secrets:
      CHECKOUT_TOKEN:
        description: |
          The Personal access token (PAT) to use with the checkout action.
        required: false
jobs:
  swift_build_and_test:
    name: Build and Test Swift on Linux
    runs-on: ${{ fromJson(inputs.runsonlabels) }}
    defaults:
      run:
        working-directory: ${{ inputs.path }}
    environment: ${{ inputs.environment }}
    steps:
      - uses: actions/checkout@v4
        with:
          # This is GitHubs way of implementing ternary expressions (see https://docs.github.com/en/actions/learn-github-actions/expressions)
          token: ${{ secrets.CHECKOUT_TOKEN != '' && secrets.CHECKOUT_TOKEN || github.token }}
          submodules: ${{ inputs.checkout_submodules }}
          lfs: ${{ inputs.checkout_lfs }}
      - name: Setup Swift
        uses: SwiftyLab/setup-swift@v1
        with:
          swift-version: ${{ inputs.swiftVersion || 'latest' }}
      - name: Build Package
        run: swift build -v
      - name: Run Tests
        run: swift test -v --enable-code-coverage
      - name: Generate Coverage Report
        if: ${{ (success() || failure()) && inputs.artifactname != '' }}
        run: |
          COVERAGE_FILE=$(find .build/*/debug/codecov -name "*.profdata" -type f | head -1) && \
          XCTEST_FILE=$(find .build/*/debug -name "*.xctest" -type f | head -1) && \
          llvm-cov export \
            "$XCTEST_FILE" \
            --instr-profile="$COVERAGE_FILE" \
            --format=lcov > tmp.lcov
      - name: Convert LCOV format
        if: ${{ (success() || failure()) && inputs.artifactname != '' }}
        shell: bash
        run: |
          python3 -c "
          import re, sys
          with open('tmp.lcov', 'r') as f:
              content = f.read()
          records = re.split(r'(?=^SF:)', content, flags=re.MULTILINE)
          result = []
          for record in records:
              if not record.strip() or not record.startswith('SF:'):
                  continue
              lines = record.strip().split('\n')
              sf_line = lines[0]
              fn_map = {}
              fnda_map = {}
              for line in lines[1:]:
                  if line.startswith('FN:'):
                      parts = line[3:].split(',', 1)
                      if len(parts) == 2:
                          fn_map[parts[1]] = parts[0]
                  elif line.startswith('FNDA:'):
                      parts = line[5:].split(',', 1)
                      if len(parts) == 2:
                          fnda_map[parts[1]] = parts[0]
              result.append(sf_line)
              for func_id, line_num in fn_map.items():
                  if func_id in fnda_map:
                      result.append(f'DA:{line_num},{fnda_map[func_id]}')
              result.append('end_of_record')
          with open('${{ inputs.path }}/${{ inputs.artifactname }}', 'w') as f:
              f.write('\n'.join(result))
          "
      - name: Upload artifact
        if: ${{ (success() || failure()) && inputs.artifactname != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifactname }}
          path: ${{ inputs.path }}/${{ inputs.artifactname }}